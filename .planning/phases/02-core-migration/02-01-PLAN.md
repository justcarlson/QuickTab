---
phase: 02-core-migration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/utils/types.ts
  - src/utils/url-matching.ts
autonomous: true

must_haves:
  truths:
    - "URL matching correctly identifies Lotus routes"
    - "URL matching correctly identifies ticket routes"
    - "URL matching rejects restricted routes (chat, voice, print)"
    - "URL matching ignores query parameters and hash fragments"
    - "URL matching works for any Zendesk subdomain"
  artifacts:
    - path: "src/utils/types.ts"
      provides: "Shared type definitions for URL matching and storage"
      exports: ["RouteMatch", "RouteType", "UrlDetectionMode", "ZendeskTabInfo", "StorageSchema"]
    - path: "src/utils/url-matching.ts"
      provides: "Pure URL matching module"
      exports: ["matchZendeskUrl", "buildZendeskUrl", "isZendeskAgentUrl"]
  key_links:
    - from: "src/utils/url-matching.ts"
      to: "src/utils/types.ts"
      via: "type imports"
      pattern: "import.*RouteMatch.*from.*types"
---

<objective>
Create shared type definitions and port URL matching logic from legacy ES5 to TypeScript

Purpose: Establish the foundation types and pure URL matching module that the service worker will depend on. URL matching is the core logic that determines which navigations to intercept and how to route them.

Output: Two TypeScript modules - types.ts with shared interfaces, and url-matching.ts with pure functions for URL pattern detection
</objective>

<execution_context>
@/home/jc/.claude/get-shit-done/workflows/execute-plan.md
@/home/jc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-migration/02-CONTEXT.md
@.planning/phases/02-core-migration/02-RESEARCH.md
@app/javascripts/modules/url_match.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create shared type definitions</name>
  <files>src/utils/types.ts</files>
  <action>
Create src/utils/types.ts with TypeScript interfaces for:

1. RouteType - Union type: 'lotus' | 'ticket'
2. RouteMatch - Interface for matched URL: { subdomain: string; path: string; type: RouteType }
3. UrlDetectionMode - Union type: 'allUrls' | 'ticketUrls' | 'noUrls'
4. ZendeskTabInfo - Interface for tracked tab: { subdomain: string; lastActive: number }
5. StorageSchema - Interface for chrome.storage structure:
   - urlDetection: UrlDetectionMode
   - quicktab_state: { zendeskTabs: Record<number, ZendeskTabInfo> }

Export all types. Use JSDoc comments for each type explaining purpose.
  </action>
  <verify>
npx tsc --noEmit src/utils/types.ts
  </verify>
  <done>
types.ts exists with all 5 type definitions, compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Port URL matching logic to TypeScript</name>
  <files>src/utils/url-matching.ts</files>
  <action>
Port app/javascripts/modules/url_match.js to src/utils/url-matching.ts with these changes:

1. Import RouteMatch and RouteType from './types'

2. Define regex patterns as constants (from legacy code):
   - LOTUS_ROUTE: Match /agent/ paths excluding chat/voice
   - TICKET_ROUTE: Match ticket-related paths
   - RESTRICTED_ROUTE: Match chat, voice, admin/voice, print URLs

3. Create matchZendeskUrl(urlString: string): RouteMatch | null
   - Use native URL constructor for parsing (not regex for protocol/host)
   - Verify hostname ends with '.zendesk.com'
   - Extract subdomain: hostname.slice(0, -'.zendesk.com'.length)
   - Use pathname only (ignores query params and hash per CONTEXT.md)
   - Check restricted routes first (return null)
   - Try ticket route match (higher priority)
   - Try lotus route match
   - Return RouteMatch object or null

4. Create buildZendeskUrl(match: RouteMatch): string
   - Returns: `https://${match.subdomain}.zendesk.com/agent${match.path}`

5. Create isZendeskAgentUrl(url: string): boolean
   - Returns true if URL is zendesk.com/agent/*

Per RESEARCH.md, use try/catch around new URL() for invalid URL handling.
  </action>
  <verify>
npx tsc --noEmit src/utils/url-matching.ts && npm run lint
  </verify>
  <done>
url-matching.ts exports all 3 functions, compiles without errors, passes linting
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles both files without errors: `npx tsc --noEmit src/utils/types.ts src/utils/url-matching.ts`
2. Biome linting passes: `npm run lint`
3. Types are correctly exported and importable
</verification>

<success_criteria>
- src/utils/types.ts exists with all shared type definitions
- src/utils/url-matching.ts exists with ported URL matching logic
- Both files compile without TypeScript errors
- Both files pass Biome linting
- URL matching uses native URL constructor (not regex for URL parsing)
- URL matching ignores query parameters and hash fragments
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-migration/02-01-SUMMARY.md`
</output>
