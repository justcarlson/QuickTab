---
phase: 02-core-migration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/utils/storage.ts
  - src/utils/tabs.ts
autonomous: true

must_haves:
  truths:
    - "Storage wrapper loads state from chrome.storage.local"
    - "Storage wrapper saves state to chrome.storage.local"
    - "Storage operations silently fallback on errors (no user-visible failures)"
    - "Tab operations handle missing tabs gracefully"
    - "Tab focus brings window to front"
  artifacts:
    - path: "src/utils/storage.ts"
      provides: "Type-safe chrome.storage wrapper with storage-first pattern"
      exports: ["loadState", "saveState", "getUrlDetection", "setUrlDetection", "clearState"]
    - path: "src/utils/tabs.ts"
      provides: "Type-safe chrome.tabs wrapper with defensive error handling"
      exports: ["focusTab", "updateTabUrl", "closeTab", "queryZendeskTabs"]
  key_links:
    - from: "src/utils/storage.ts"
      to: "chrome.storage.local"
      via: "async get/set calls"
      pattern: "chrome\\.storage\\.local\\.(get|set)"
    - from: "src/utils/tabs.ts"
      to: "chrome.tabs"
      via: "async tab operations"
      pattern: "chrome\\.tabs\\.(get|update|remove|query)"
---

<objective>
Create type-safe Chrome API wrappers for storage and tabs with storage-first architecture

Purpose: Provide typed wrappers around chrome.storage.local and chrome.tabs APIs that handle MV3 service worker lifecycle requirements. Storage wrapper implements the storage-first pattern where state is loaded fresh on each operation and saved immediately after changes.

Output: Two TypeScript modules - storage.ts for chrome.storage operations with silent fallback, and tabs.ts for chrome.tabs operations with defensive error handling
</objective>

<execution_context>
@/home/jc/.claude/get-shit-done/workflows/execute-plan.md
@/home/jc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-migration/02-CONTEXT.md
@.planning/phases/02-core-migration/02-RESEARCH.md
@app/javascripts/browser/storage.js
@app/javascripts/browser/tabs.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create type-safe storage wrapper</name>
  <files>src/utils/storage.ts</files>
  <action>
Create src/utils/storage.ts implementing storage-first architecture per RESEARCH.md:

1. Import types from './types': StorageSchema, ZendeskTabInfo, UrlDetectionMode

2. Define STORAGE_KEY constant: 'quicktab_state'

3. Define DEFAULT_STATE constant: { zendeskTabs: {} }

4. Create async loadState(): Promise<StorageSchema['quicktab_state']>
   - Use try/catch around chrome.storage.local.get(STORAGE_KEY)
   - Return result.quicktab_state ?? DEFAULT_STATE
   - On error: console.warn and return DEFAULT_STATE (silent fallback per CONTEXT.md)

5. Create async saveState(state: StorageSchema['quicktab_state']): Promise<void>
   - Use try/catch around chrome.storage.local.set({ [STORAGE_KEY]: state })
   - On error: console.warn only (silent fallback per CONTEXT.md)

6. Create async getUrlDetection(): Promise<UrlDetectionMode>
   - Get 'urlDetection' from chrome.storage.local
   - Return result ?? 'allUrls' (default)

7. Create async setUrlDetection(mode: UrlDetectionMode): Promise<void>
   - Set 'urlDetection' in chrome.storage.local

8. Create async clearState(): Promise<void>
   - Remove STORAGE_KEY from chrome.storage.local
   - Use try/catch with console.warn on error

Use Record<number, ZendeskTabInfo> (not Map) for serialization per RESEARCH.md pitfall #4.
  </action>
  <verify>
npx tsc --noEmit src/utils/storage.ts && npm run lint
  </verify>
  <done>
storage.ts exports all 5 functions, compiles without errors, uses Record not Map
  </done>
</task>

<task type="auto">
  <name>Task 2: Create type-safe tabs wrapper</name>
  <files>src/utils/tabs.ts</files>
  <action>
Create src/utils/tabs.ts with defensive tab operations per RESEARCH.md pitfall #3:

1. Create async focusTab(tabId: number): Promise<boolean>
   - try: chrome.tabs.get(tabId) to verify exists
   - then: chrome.tabs.update(tabId, { active: true, highlighted: true })
   - then: chrome.windows.update(tab.windowId, { focused: true })
   - return true on success
   - catch: return false (tab no longer exists)

2. Create async updateTabUrl(tabId: number, url: string): Promise<boolean>
   - try: chrome.tabs.update(tabId, { url })
   - return true on success
   - catch: return false

3. Create async closeTab(tabId: number): Promise<void>
   - try: chrome.tabs.remove(tabId)
   - catch: ignore (tab already closed)

4. Create async queryZendeskTabs(): Promise<chrome.tabs.Tab[]>
   - return chrome.tabs.query({ url: '*://*.zendesk.com/agent/*' })

All functions use async/await with MV3 Promise-native APIs (no callbacks).
All tab operations wrapped in try/catch for defensive handling.
  </action>
  <verify>
npx tsc --noEmit src/utils/tabs.ts && npm run lint
  </verify>
  <done>
tabs.ts exports all 4 functions, compiles without errors, all operations in try/catch
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles both files: `npx tsc --noEmit src/utils/storage.ts src/utils/tabs.ts`
2. Biome linting passes: `npm run lint`
3. Storage uses Record<> not Map for serialization
4. All tab operations wrapped in try/catch
5. Silent error handling (console.warn, not throw)
</verification>

<success_criteria>
- src/utils/storage.ts exists with storage-first pattern implementation
- src/utils/tabs.ts exists with defensive tab operations
- Both files compile without TypeScript errors
- Both files pass Biome linting
- Storage uses Record<number, ZendeskTabInfo> not Map
- All Chrome API calls use async/await (MV3 Promise-native)
- Error handling follows silent fallback per CONTEXT.md
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-migration/02-02-SUMMARY.md`
</output>
