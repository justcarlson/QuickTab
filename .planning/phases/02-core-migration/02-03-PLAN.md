---
phase: 02-core-migration
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - entrypoints/background.ts
autonomous: true

must_haves:
  truths:
    - "Extension intercepts Zendesk navigation events"
    - "Navigation routes to existing agent tabs instead of opening new ones"
    - "Service worker state persists via chrome.storage (survives termination)"
    - "All event listeners register synchronously at module scope"
    - "Multiple tabs: routes to most recently active tab for subdomain"
  artifacts:
    - path: "entrypoints/background.ts"
      provides: "Service worker with navigation interception and tab routing"
      exports: ["defineBackground"]
      min_lines: 100
  key_links:
    - from: "entrypoints/background.ts"
      to: "src/utils/url-matching.ts"
      via: "matchZendeskUrl import"
      pattern: "import.*matchZendeskUrl.*from.*url-matching"
    - from: "entrypoints/background.ts"
      to: "src/utils/storage.ts"
      via: "loadState/saveState imports"
      pattern: "import.*(loadState|saveState).*from.*storage"
    - from: "entrypoints/background.ts"
      to: "src/utils/tabs.ts"
      via: "focusTab/closeTab imports"
      pattern: "import.*(focusTab|closeTab).*from.*tabs"
    - from: "entrypoints/background.ts"
      to: "chrome.webNavigation"
      via: "event listeners"
      pattern: "chrome\\.webNavigation\\.on(BeforeNavigate|Committed|DOMContentLoaded)"
---

<objective>
Implement the service worker with storage-first navigation interception and tab routing

Purpose: This is the core extension logic - intercept Zendesk navigation events and route them to existing agent tabs. The service worker must register all event listeners synchronously and persist state to chrome.storage to survive termination.

Output: Complete background.ts service worker that replicates existing extension behavior with MV3-compliant architecture
</objective>

<execution_context>
@/home/jc/.claude/get-shit-done/workflows/execute-plan.md
@/home/jc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-migration/02-CONTEXT.md
@.planning/phases/02-core-migration/02-RESEARCH.md
@.planning/phases/02-core-migration/02-01-SUMMARY.md
@.planning/phases/02-core-migration/02-02-SUMMARY.md
@app/javascripts/browser/listeners.js
@app/javascripts/modules/browser.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement service worker with navigation interception</name>
  <files>entrypoints/background.ts</files>
  <action>
Replace entrypoints/background.ts with full service worker implementation:

1. IMPORTS (at top, outside defineBackground):
   - Import matchZendeskUrl, buildZendeskUrl from '@/utils/url-matching'
   - Import loadState, saveState, getUrlDetection, clearState from '@/utils/storage'
   - Import focusTab, updateTabUrl, closeTab, queryZendeskTabs from '@/utils/tabs'
   - Import RouteMatch from '@/utils/types'

2. HELPER FUNCTIONS (outside defineBackground):
   - findMostRecentTab(state, subdomain): Find tab with highest lastActive for subdomain
   - handleNavigation(sourceTabId, sourceUrl, match): Core routing logic

3. Inside defineBackground(() => { ... }) - ALL LISTENERS SYNCHRONOUS:

   a) Console log for lifecycle debugging: console.log('QuickTab service worker started')

   b) chrome.runtime.onInstalled.addListener((details) => { ... })
      - If reason === 'install': open welcome page via chrome.tabs.create
      - If reason === 'update': clearState() to reset per CONTEXT.md
      - Re-detect existing Zendesk tabs via queryZendeskTabs() and populate state

   c) chrome.webNavigation.onBeforeNavigate.addListener(async (details) => { ... })
      - Filter: { url: [{ hostSuffix: 'zendesk.com' }] }
      - Only handle frameId === 0 (main frame)
      - Get urlDetection mode; return early if 'noUrls'
      - Call matchZendeskUrl(details.url)
      - If mode === 'ticketUrls' and match.type !== 'ticket', return
      - If match, call handleNavigation

   d) chrome.webNavigation.onCommitted.addListener(async (details) => { ... })
      - Same filter and logic as onBeforeNavigate (handles redirects)

   e) chrome.webNavigation.onDOMContentLoaded.addListener(async (details) => { ... })
      - Filter: { url: [{ urlContains: 'zendesk.com/agent' }] }
      - Only frameId === 0
      - Track tab in state with current subdomain and lastActive timestamp
      - Update action icon state based on urlDetection mode

4. handleNavigation implementation:
   - Load state with loadState()
   - Find existing tab for this subdomain (not the source tab)
   - If found: updateTabUrl, focusTab, closeTab(source), save state
   - If not found: track this tab in state, save state

5. Track tab on navigation:
   - Extract subdomain from URL
   - Add/update entry in state.zendeskTabs[tabId] = { subdomain, lastActive: Date.now() }
   - saveState()

Per RESEARCH.md:
- NO async in defineBackground callback signature
- NO global variables for state
- ALL listeners in first event loop tick (synchronous registration)
- Async work only INSIDE listener callbacks
  </action>
  <verify>
npm run build && ls -la .output/chrome-mv3/background.js
  </verify>
  <done>
background.ts compiles, build produces background.js, all listeners registered synchronously at module scope
  </done>
</task>

<task type="auto">
  <name>Task 2: Add action icon state management</name>
  <files>entrypoints/background.ts</files>
  <action>
Add to background.ts - icon state management per existing behavior:

1. Create function setActionIcon(mode: UrlDetectionMode): void
   - Determine icon path: '/images/icons/icon38-enabled.png' or 'icon38-disabled.png'
   - enabled if mode !== 'noUrls', disabled otherwise
   - Query all Zendesk agent tabs via chrome.tabs.query
   - Set icon for each tab via chrome.action.setIcon

2. In onDOMContentLoaded listener:
   - After tracking tab, call chrome.action.enable(tabId)
   - Call setActionIcon(mode) to update icon state

3. Export a message handler for popup communication (for Phase 3):
   - Add chrome.runtime.onMessage listener
   - Handle 'getStatus' message: return current urlDetection mode
   - Handle 'setMode' message: save new mode, update icons

This enables the popup (Phase 3) to communicate with background and toggle detection mode.
  </action>
  <verify>
npm run build && npm run lint
  </verify>
  <done>
Action icon management works, message handler ready for popup, build succeeds
  </done>
</task>

</tasks>

<verification>
1. Build succeeds: `npm run build`
2. Linting passes: `npm run lint`
3. background.js exists in .output/chrome-mv3/
4. No async in defineBackground signature
5. All chrome.*.addListener calls are at module scope (not in callbacks)
</verification>

<success_criteria>
- entrypoints/background.ts fully implements service worker
- All event listeners register synchronously at module scope
- Navigation interception uses storage-first pattern (loadState on each event)
- Tab routing matches existing behavior (most recent tab, focus, close source)
- Action icon state updates based on detection mode
- Message handler ready for popup communication
- Build produces loadable extension
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-migration/02-03-SUMMARY.md`
</output>
