---
phase: 04-testing-quality
plan: 05
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - playwright.config.ts
  - e2e/fixtures.ts
  - e2e/popup.spec.ts
  - e2e/mock-pages/agent-ticket.html
autonomous: true

must_haves:
  truths:
    - "E2E tests run against built extension in real browser"
    - "Popup UI displays and mode toggle works"
    - "Extension loads without errors"
  artifacts:
    - path: "playwright.config.ts"
      provides: "Playwright configuration for extension testing"
      contains: "testDir.*e2e"
    - path: "e2e/fixtures.ts"
      provides: "Extension loading fixtures"
      contains: "extensionId"
    - path: "e2e/popup.spec.ts"
      provides: "Popup UI E2E tests"
      min_lines: 30
  key_links:
    - from: "playwright.config.ts"
      to: "e2e/"
      via: "testDir configuration"
      pattern: "testDir.*e2e"
    - from: "e2e/fixtures.ts"
      to: ".output/chrome-mv3"
      via: "extension path"
      pattern: "\\.output.*chrome-mv3"
---

<objective>
Set up Playwright E2E testing infrastructure and create popup UI tests.

Purpose: E2E tests verify the extension works in a real browser context - critical for user-facing functionality.
Output: Working E2E test suite that loads extension and tests popup.
</objective>

<execution_context>
@/home/jc/.claude/get-shit-done/workflows/execute-plan.md
@/home/jc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-testing-quality/04-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Playwright configuration</name>
  <files>playwright.config.ts</files>
  <action>
Create playwright.config.ts at project root:

```typescript
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './e2e',
  // Extensions need sequential execution - no parallelism
  fullyParallel: false,
  workers: 1,
  // Fail CI if test.only left in
  forbidOnly: !!process.env.CI,
  // Retry on CI for flaky extension loading
  retries: process.env.CI ? 2 : 0,
  reporter: process.env.CI ? 'github' : 'html',
  use: {
    // Capture trace on first retry for debugging
    trace: 'on-first-retry',
  },
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
  ],
  // Build extension before running E2E tests
  webServer: {
    command: 'npm run build',
    reuseExistingServer: true,
  },
});
```

Per RESEARCH.md:
- Single worker for extension testing (extensions need sequential context)
- fullyParallel: false prevents extension conflicts
- webServer.command ensures extension is built before tests
  </action>
  <verify>
`grep -q "testDir.*e2e" playwright.config.ts` confirms test directory.
`npx playwright test --help` shows Playwright ready.
  </verify>
  <done>Playwright configuration created for extension testing.</done>
</task>

<task type="auto">
  <name>Task 2: Create extension fixtures</name>
  <files>e2e/fixtures.ts</files>
  <action>
Create e2e/fixtures.ts with reusable extension loading:

```typescript
/**
 * Playwright fixtures for Chrome extension E2E testing
 *
 * Per RESEARCH.md Pattern 3: Extension fixtures with persistent context
 */
import { test as base, chromium, type BrowserContext } from '@playwright/test';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

export const test = base.extend<{
  context: BrowserContext;
  extensionId: string;
}>({
  // Override context to load extension
  context: async ({}, use) => {
    const pathToExtension = path.join(__dirname, '../.output/chrome-mv3');
    const context = await chromium.launchPersistentContext('', {
      headless: false, // Extensions require headed mode
      args: [
        '--headless=new', // Use new headless mode that supports extensions
        `--disable-extensions-except=${pathToExtension}`,
        `--load-extension=${pathToExtension}`,
      ],
    });
    await use(context);
    await context.close();
  },
  // Derive extension ID from service worker URL
  extensionId: async ({ context }, use) => {
    // Wait for service worker to be available (MV3)
    let [serviceWorker] = context.serviceWorkers();
    if (!serviceWorker) {
      serviceWorker = await context.waitForEvent('serviceworker');
    }
    // Extract extension ID from service worker URL
    // Format: chrome-extension://[extension-id]/background.js
    const extensionId = serviceWorker.url().split('/')[2];
    await use(extensionId);
  },
});

export { expect } from '@playwright/test';
```

Per RESEARCH.md Pitfall 4: Wait for serviceworker event to prevent flaky tests.
  </action>
  <verify>
`grep -q "extensionId" e2e/fixtures.ts` confirms fixture exists.
Directory structure: `ls e2e/` shows fixtures.ts.
  </verify>
  <done>Extension fixtures created with proper service worker waiting.</done>
</task>

<task type="auto">
  <name>Task 3: Create popup E2E tests</name>
  <files>e2e/popup.spec.ts, e2e/mock-pages/agent-ticket.html</files>
  <action>
Create e2e/popup.spec.ts testing popup UI:

```typescript
import { test, expect } from './fixtures';

test.describe('Popup UI', () => {
  test('should load popup and display mode options', async ({ context, extensionId }) => {
    // Open popup page directly
    const popup = await context.newPage();
    await popup.goto(`chrome-extension://${extensionId}/popup.html`);

    // Verify popup loaded
    await expect(popup.locator('body')).toBeVisible();

    // Verify mode toggle exists with three options
    await expect(popup.locator('input[type="radio"]')).toHaveCount(3);

    // Verify current mode indicator exists
    await expect(popup.locator('#all-urls-mode')).toBeVisible();
    await expect(popup.locator('#ticket-urls-mode')).toBeVisible();
    await expect(popup.locator('#no-urls-mode')).toBeVisible();
  });

  test('should change mode when radio button clicked', async ({ context, extensionId }) => {
    const popup = await context.newPage();
    await popup.goto(`chrome-extension://${extensionId}/popup.html`);

    // Get the ticket URLs radio button and click it
    const ticketUrlsRadio = popup.locator('#ticket-urls-mode');
    await ticketUrlsRadio.click();

    // Verify it's now checked
    await expect(ticketUrlsRadio).toBeChecked();
  });

  test('should persist mode after popup reopen', async ({ context, extensionId }) => {
    // Open popup and change mode
    const popup1 = await context.newPage();
    await popup1.goto(`chrome-extension://${extensionId}/popup.html`);
    await popup1.locator('#no-urls-mode').click();
    await popup1.close();

    // Reopen popup
    const popup2 = await context.newPage();
    await popup2.goto(`chrome-extension://${extensionId}/popup.html`);

    // Verify mode persisted
    await expect(popup2.locator('#no-urls-mode')).toBeChecked();
  });
});
```

Create e2e/mock-pages/agent-ticket.html (minimal mock page):

```html
<!DOCTYPE html>
<html>
<head>
  <title>Zendesk Agent - Ticket #123</title>
</head>
<body>
  <h1>Mock Zendesk Agent Page</h1>
  <p>This page simulates a Zendesk agent ticket view for E2E testing.</p>
  <p>URL pattern: company.zendesk.com/agent/tickets/123</p>
</body>
</html>
```
  </action>
  <verify>
`npm run build && npm run test:e2e` runs E2E tests (may need `--headed` for debugging).
`ls e2e/` shows popup.spec.ts and mock-pages/.
  </verify>
  <done>Popup E2E tests created and passing.</done>
</task>

</tasks>

<verification>
1. `npm run test:e2e` executes E2E tests
2. Popup loads with three mode radio buttons
3. Mode changes persist across popup reopens
4. Extension ID derived correctly from service worker
</verification>

<success_criteria>
- [ ] Playwright configured for extension E2E testing
- [ ] Extension fixtures load extension in persistent context
- [ ] Popup UI tests verify mode toggle functionality
- [ ] Mode persistence tested across popup reopens
- [ ] E2E tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-testing-quality/04-05-SUMMARY.md`
</output>
