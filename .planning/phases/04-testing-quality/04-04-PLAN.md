---
phase: 04-testing-quality
plan: 04
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - entrypoints/background.test.ts
autonomous: true

must_haves:
  truths:
    - "Message handlers respond correctly to getStatus and setMode"
    - "findMostRecentTab selects correct tab by lastActive timestamp"
    - "State persistence verified for service worker restart scenario"
  artifacts:
    - path: "entrypoints/background.test.ts"
      provides: "Unit tests for service worker"
      min_lines: 100
  key_links:
    - from: "entrypoints/background.test.ts"
      to: "entrypoints/background.ts"
      via: "import/test coverage"
      pattern: "background"
---

<objective>
Create unit tests for the background service worker focusing on testable functions.

Purpose: Service worker is the core extension logic - must verify message handling, tab selection, and state persistence.
Output: Test file covering internal functions and message handlers.
</objective>

<execution_context>
@/home/jc/.claude/get-shit-done/workflows/execute-plan.md
@/home/jc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-testing-quality/04-RESEARCH.md
@entrypoints/background.ts
@src/utils/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor background.ts to export testable functions</name>
  <files>entrypoints/background.ts</files>
  <action>
The background.ts file has internal functions that need testing but aren't exported.
Export the key internal functions for unit testing:

Add exports for:
- `findMostRecentTab` - critical business logic for tab selection
- `setActionIcon` - icon state management
- `handleNavigation` - core routing logic (optional, complex dependencies)
- `trackTab` - tab tracking logic

At the bottom of background.ts, add:
```typescript
// Exports for testing - these functions are also used internally
export { findMostRecentTab, setActionIcon, trackTab };
```

Note: Keep the main logic inside defineBackground() for WXT compatibility.
The exports allow direct testing of pure functions.
  </action>
  <verify>
`grep -q "export.*findMostRecentTab" entrypoints/background.ts` confirms export.
Build still works: `npm run build` succeeds.
  </verify>
  <done>Testable functions exported from background.ts.</done>
</task>

<task type="auto">
  <name>Task 2: Create background service worker unit tests</name>
  <files>entrypoints/background.test.ts</files>
  <action>
Create entrypoints/background.test.ts with tests for:

Test `findMostRecentTab`:
1. Returns null when no tabs exist
2. Returns null when only the excluded tab exists
3. Returns tab ID with highest lastActive for matching subdomain
4. Ignores tabs with different subdomain
5. Handles multiple tabs, selects most recent

Test state persistence pattern (TEST-08):
1. Set up state via storage
2. Verify findMostRecentTab works with state from storage
3. Simulate "restart" by resetting in-memory state but keeping storage
4. Verify state reloaded correctly from storage

Test message handlers (via chrome.runtime.onMessage):
1. getStatus message returns current mode
2. setMode message updates mode and returns true
3. Unknown message type returns false

For message handler testing, use the pattern:
```typescript
// Trigger message listener
const sendResponse = vi.fn();
chrome.runtime.onMessage.callListeners(
  { type: 'getStatus' },
  { tab: { id: 1 } },
  sendResponse
);
await vi.waitFor(() => expect(sendResponse).toHaveBeenCalled());
```

Note: If vitest-chrome's callListeners is needed, install it:
```bash
npm install -D vitest-chrome
```
And use chrome from vitest-chrome for event triggering.
  </action>
  <verify>
`npm test -- --run entrypoints/background.test.ts` passes all tests.
  </verify>
  <done>Background service worker tests pass.</done>
</task>

<task type="auto">
  <name>Task 3: Test service worker state persistence (TEST-08)</name>
  <files>entrypoints/background.test.ts</files>
  <action>
Add specific tests for service worker termination scenario per TEST-08.

The pattern simulates service worker restart:
1. Initialize state via storage (represents "before termination")
2. Clear any in-memory state (simulate termination)
3. Load state fresh from storage (represents "after restart")
4. Verify business logic works correctly with loaded state

Test cases:
1. Tab tracking survives restart:
   - Save state with tracked tabs
   - Load state (simulating restart)
   - Verify findMostRecentTab finds the tabs

2. URL detection mode survives restart:
   - Set mode via setUrlDetection
   - Load mode fresh (simulating restart)
   - Verify mode is correct

3. State cleared on update:
   - Save state with data
   - Call clearState (simulating extension update)
   - Load state
   - Verify default state returned

These tests verify the storage-first architecture works correctly.
  </action>
  <verify>
`npm test -- --run entrypoints/background.test.ts` shows all persistence tests pass.
`grep -c "restart\|persistence\|terminate" entrypoints/background.test.ts` shows >=3 related tests.
  </verify>
  <done>Service worker state persistence tests verify storage-first architecture.</done>
</task>

</tasks>

<verification>
1. `npm test -- --run entrypoints/background.test.ts` passes
2. findMostRecentTab logic thoroughly tested
3. Message handlers (getStatus, setMode) tested
4. State persistence across "restart" verified
5. Coverage >90% for background.ts (excluding event registration boilerplate)
</verification>

<success_criteria>
- [ ] findMostRecentTab tested with various tab configurations
- [ ] Message handlers respond correctly to popup messages
- [ ] State persistence verified (TEST-08)
- [ ] Testable functions exported and tested
- [ ] All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-testing-quality/04-04-SUMMARY.md`
</output>
