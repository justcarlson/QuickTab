---
phase: 04-testing-quality
plan: 04
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - entrypoints/background.test.ts
autonomous: true

must_haves:
  truths:
    - "Message handlers tested via chrome.runtime.sendMessage mocking"
    - "findMostRecentTab selects correct tab by lastActive timestamp"
    - "State persistence verified through storage observation"
  artifacts:
    - path: "entrypoints/background.test.ts"
      provides: "Unit tests for service worker"
      min_lines: 100
  key_links:
    - from: "entrypoints/background.test.ts"
      to: "entrypoints/background.ts"
      via: "import/test coverage"
      pattern: "background"
---

<objective>
Create unit tests for the background service worker focusing on testable functions.

Purpose: Service worker is the core extension logic - must verify message handling, tab selection, and state persistence.
Output: Test file covering internal functions and message handlers.
</objective>

<execution_context>
@/home/jc/.claude/get-shit-done/workflows/execute-plan.md
@/home/jc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-testing-quality/04-RESEARCH.md
@entrypoints/background.ts
@src/utils/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create background service worker unit tests</name>
  <files>entrypoints/background.test.ts</files>
  <action>
Create entrypoints/background.test.ts with tests for storage and message behavior.

**Note on Architecture:** The functions `findMostRecentTab`, `setActionIcon`, `trackTab`,
and `handleNavigation` are defined at module scope OUTSIDE defineBackground() but are
private (not exported). The message handlers are inside defineBackground() and also
cannot be exported.

**Testing Strategy:** Test behavior through:
1. Storage state observation (input/output via fake-browser storage)
2. Message handler mocking via chrome.runtime.sendMessage

Test message handlers (via storage observation):
1. `getStatus` - call sendMessage, verify response contains current mode
2. `setMode` - call sendMessage with new mode, verify storage.local updated

Test storage-first architecture:
1. Pre-populate storage with tab tracking state
2. Import background module to register listeners
3. Trigger navigation events via fake-browser
4. Verify storage state changes correctly

For message testing pattern (behavior-based):
```typescript
import { describe, it, expect, beforeEach } from 'vitest';
import { fakeBrowser } from 'wxt/testing/fake-browser';

describe('background message handlers', () => {
  beforeEach(() => {
    fakeBrowser.reset();
  });

  it('getStatus returns current mode', async () => {
    // Pre-set mode in storage
    await fakeBrowser.storage.local.set({ urlDetection: 'ticketUrls' });

    // Import background to register handlers (side effect import)
    await import('./background');

    // Test via sendMessage - the handler will read from storage
    const response = await chrome.runtime.sendMessage({ type: 'getStatus' });
    expect(response.mode).toBe('ticketUrls');
  });
});
```

Note: This tests observable behavior without requiring internal function exports.
  </action>
  <verify>
`npm test -- --run entrypoints/background.test.ts` passes all tests.
  </verify>
  <done>Background service worker tests pass via behavior testing.</done>
</task>

<task type="auto">
  <name>Task 2: Test service worker state persistence (TEST-08)</name>
  <files>entrypoints/background.test.ts</files>
  <action>
Add specific tests for service worker termination scenario per TEST-08.

**Testing Strategy:** Test storage-first persistence through storage observation.
Since all state is in chrome.storage.local, verify behavior by:
1. Pre-populating storage (simulates "before termination")
2. Clearing JS module cache to simulate fresh import (termination)
3. Re-importing module and verifying it loads state from storage

Test cases:
1. Tab tracking survives restart:
   - Pre-populate storage with tracked tabs via fakeBrowser.storage.local.set()
   - Fresh import of storage utils
   - Call loadState() and verify tabs present

2. URL detection mode survives restart:
   - Set mode via storage directly
   - Fresh import
   - Call getUrlDetection() and verify mode is correct

3. State cleared on update:
   - Pre-populate storage with data
   - Call clearState() (imported from storage utils)
   - Call loadState() and verify default state returned

Pattern for testing storage persistence:
```typescript
describe('state persistence', () => {
  it('tabs survive service worker restart', async () => {
    // Pre-populate storage (simulates state before termination)
    await fakeBrowser.storage.local.set({
      quicktabState: {
        zendeskTabs: { 123: { subdomain: 'company', lastActive: 1000 } }
      }
    });

    // Import storage utils fresh (simulates restart)
    const { loadState } = await import('@/src/utils/storage');

    // Verify state loaded from storage
    const state = await loadState();
    expect(state.zendeskTabs[123]).toBeDefined();
    expect(state.zendeskTabs[123].subdomain).toBe('company');
  });
});
```

Note: Tests storage layer behavior, not internal background.ts functions.
  </action>
  <verify>
`npm test -- --run entrypoints/background.test.ts` shows all persistence tests pass.
`grep -c "restart\|persistence\|survive" entrypoints/background.test.ts` shows >=3 related tests.
  </verify>
  <done>Service worker state persistence tests verify storage-first architecture.</done>
</task>

</tasks>

<verification>
1. `npm test -- --run entrypoints/background.test.ts` passes
2. Message handlers tested via storage observation (getStatus, setMode)
3. State persistence across "restart" verified through storage
4. Storage-first architecture verified (no in-memory state leakage)
</verification>

<success_criteria>
- [ ] Message handlers tested via sendMessage + storage observation
- [ ] State persistence verified through storage (TEST-08)
- [ ] Storage-first architecture tested (loadState/saveState behavior)
- [ ] All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-testing-quality/04-04-SUMMARY.md`
</output>
