---
phase: 04-testing-quality
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - vitest.config.ts
  - vitest.setup.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "`npm test` runs Vitest and reports results"
    - "Chrome API mocking available via fake-browser"
    - "Coverage reports generated in text, HTML, and lcov formats"
  artifacts:
    - path: "vitest.config.ts"
      provides: "Vitest configuration with WxtVitest plugin"
      contains: "WxtVitest"
    - path: "vitest.setup.ts"
      provides: "Global test setup with fake-browser reset"
      contains: "fakeBrowser.reset"
    - path: "package.json"
      provides: "Test scripts and dependencies"
      contains: "vitest"
  key_links:
    - from: "vitest.config.ts"
      to: "vitest.setup.ts"
      via: "setupFiles array"
      pattern: "setupFiles.*vitest\\.setup"
---

<objective>
Configure Vitest test runner with WXT integration and coverage reporting.

Purpose: Establish the test infrastructure that all subsequent test plans depend on.
Output: Working `npm test` command with Chrome API mocking and coverage thresholds.
</objective>

<execution_context>
@/home/jc/.claude/get-shit-done/workflows/execute-plan.md
@/home/jc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-testing-quality/04-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install test dependencies</name>
  <files>package.json</files>
  <action>
Install Vitest 3.x, coverage provider, and Playwright:

```bash
npm install -D vitest @vitest/coverage-v8 @playwright/test
npx playwright install chromium
```

Add test scripts to package.json:
- "test": "vitest"
- "test:coverage": "vitest run --coverage"
- "test:e2e": "playwright test"

Note: @webext-core/fake-browser is bundled with WXT's testing plugin (no separate install).
  </action>
  <verify>
`npm test -- --help` shows Vitest help.
`npm run test:coverage -- --help` shows coverage options.
`npx playwright --version` shows Playwright version.
  </verify>
  <done>Test dependencies installed and scripts available in package.json.</done>
</task>

<task type="auto">
  <name>Task 2: Create Vitest configuration with WXT plugin</name>
  <files>vitest.config.ts</files>
  <action>
Create vitest.config.ts at project root:

```typescript
import { defineConfig } from 'vitest/config';
import { WxtVitest } from 'wxt/testing/vitest-plugin';

export default defineConfig({
  plugins: [WxtVitest()],
  test: {
    setupFiles: ['./vitest.setup.ts'],
    include: ['src/**/*.test.ts', 'entrypoints/**/*.test.ts'],
    coverage: {
      provider: 'v8',
      reporter: ['text', 'html', 'lcov'],
      reportsDirectory: './coverage',
      include: ['src/**/*.ts', 'entrypoints/**/*.ts'],
      exclude: [
        '**/*.test.ts',
        '**/types.ts',
        'entrypoints/popup/main.ts',
        'entrypoints/welcome/main.ts',
      ],
      thresholds: {
        // Global minimum threshold
        lines: 70,
        functions: 70,
        branches: 70,
        statements: 70,
      },
    },
  },
});
```

Per RESEARCH.md:
- WxtVitest() auto-configures Chrome API mocking and path aliases
- v8 provider is faster than Istanbul with same accuracy since Vitest 3.2.0
- Exclude types.ts (no logic) and UI entry files (E2E covers these)
  </action>
  <verify>
`npx vitest --version` succeeds.
`grep -q "WxtVitest" vitest.config.ts` confirms plugin usage.
  </verify>
  <done>Vitest config created with WXT integration and coverage thresholds.</done>
</task>

<task type="auto">
  <name>Task 3: Create global test setup with mock reset</name>
  <files>vitest.setup.ts</files>
  <action>
Create vitest.setup.ts at project root:

```typescript
/**
 * Global Vitest setup - runs before each test file
 *
 * Per RESEARCH.md Pattern 2: Reset fake-browser state between tests
 * to prevent state leakage causing flaky tests.
 */
import { fakeBrowser } from 'wxt/testing/fake-browser';
import { beforeEach, vi } from 'vitest';

beforeEach(() => {
  // Reset all fake-browser state (storage, tabs, etc.)
  fakeBrowser.reset();
  // Clear all Vitest mocks
  vi.clearAllMocks();
});
```

This ensures:
- Clean slate for each test (no state leakage per RESEARCH.md Pitfall 3)
- Mock functions reset between tests
  </action>
  <verify>
`grep -q "fakeBrowser.reset" vitest.setup.ts` confirms reset pattern.
`npm test -- --run 2>&1 | head -20` runs without import errors.
  </verify>
  <done>Test setup file created with fake-browser reset pattern.</done>
</task>

</tasks>

<verification>
1. `npm test -- --run` executes without errors (may show "no tests found" initially)
2. `npm run test:coverage -- --run` generates coverage directory
3. `ls coverage/` shows html, lcov-report directories
4. `cat vitest.config.ts | grep -A5 thresholds` shows 70% global thresholds
</verification>

<success_criteria>
- [ ] `npm test` command works and shows Vitest output
- [ ] Coverage reports generate in text, HTML, and lcov formats
- [ ] vitest.setup.ts resets fake-browser state before each test
- [ ] Package.json has test, test:coverage, and test:e2e scripts
</success_criteria>

<output>
After completion, create `.planning/phases/04-testing-quality/04-01-SUMMARY.md`
</output>
