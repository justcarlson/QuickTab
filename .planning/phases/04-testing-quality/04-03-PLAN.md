---
phase: 04-testing-quality
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/utils/storage.test.ts
  - src/utils/tabs.test.ts
autonomous: true

must_haves:
  truths:
    - "Storage operations persist and retrieve state correctly"
    - "Storage operations handle errors gracefully with fallback values"
    - "Tab operations return boolean success for caller cleanup"
    - "Tab operations handle missing tabs gracefully"
  artifacts:
    - path: "src/utils/storage.test.ts"
      provides: "Unit tests for storage module"
      min_lines: 80
    - path: "src/utils/tabs.test.ts"
      provides: "Unit tests for tabs module"
      min_lines: 60
  key_links:
    - from: "src/utils/storage.test.ts"
      to: "src/utils/storage.ts"
      via: "import statements"
      pattern: "from.*storage"
    - from: "src/utils/tabs.test.ts"
      to: "src/utils/tabs.ts"
      via: "import statements"
      pattern: "from.*tabs"
---

<objective>
Create unit tests for storage and tabs Chrome API wrapper modules.

Purpose: Storage and tabs wrappers are critical for MV3 persistence and tab routing.
Output: Test files with >90% coverage of storage.ts and tabs.ts.
</objective>

<execution_context>
@/home/jc/.claude/get-shit-done/workflows/execute-plan.md
@/home/jc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-testing-quality/04-RESEARCH.md
@src/utils/storage.ts
@src/utils/tabs.ts
@src/utils/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create storage module unit tests</name>
  <files>src/utils/storage.test.ts</files>
  <action>
Create src/utils/storage.test.ts testing all five exported functions.

Test `loadState`:
1. Returns default state when storage is empty: `{ zendeskTabs: {} }`
2. Returns stored state when data exists
3. Returns default state on storage error (silent fallback)

Test `saveState`:
1. Persists state to storage
2. Stored state retrievable via loadState
3. Silent fallback on storage error (no throw)

Test `getUrlDetection`:
1. Returns 'allUrls' when no mode set (default)
2. Returns stored mode when set
3. Returns 'allUrls' on storage error (fallback)

Test `setUrlDetection`:
1. Persists mode to storage
2. Mode retrievable via getUrlDetection
3. All three modes work: 'allUrls', 'ticketUrls', 'noUrls'
4. Silent fallback on storage error

Test `clearState`:
1. Removes quicktab_state from storage
2. loadState returns default after clear
3. Silent fallback on storage error

Per RESEARCH.md Pattern 4: fakeBrowser provides stateful in-memory storage.
fakeBrowser.reset() in beforeEach ensures test isolation.
  </action>
  <verify>
`npm test -- --run src/utils/storage.test.ts` passes all tests.
  </verify>
  <done>Storage tests pass with coverage of all functions and error paths.</done>
</task>

<task type="auto">
  <name>Task 2: Create tabs module unit tests</name>
  <files>src/utils/tabs.test.ts</files>
  <action>
Create src/utils/tabs.test.ts testing all four exported functions.

Test `focusTab`:
1. Returns true and focuses existing tab
2. Brings window to front via chrome.windows.update
3. Returns false when tab doesn't exist

Test `updateTabUrl`:
1. Returns true and updates URL for existing tab
2. Returns false when tab doesn't exist

Test `closeTab`:
1. Closes existing tab without error
2. Silently ignores when tab already closed

Test `queryZendeskTabs`:
1. Returns matching tabs for Zendesk agent URL pattern
2. Returns empty array when no matching tabs

Per RESEARCH.md: fakeBrowser provides chrome.tabs mock.
For tab operations, may need to pre-populate tabs via fakeBrowser or mock specific methods.

Note: If fakeBrowser lacks full tabs.get/update support, use vi.spyOn to mock:
```typescript
vi.spyOn(chrome.tabs, 'get').mockResolvedValue({ id: 1, windowId: 1, ... });
vi.spyOn(chrome.tabs, 'update').mockResolvedValue({ id: 1, ... });
```
  </action>
  <verify>
`npm test -- --run src/utils/tabs.test.ts` passes all tests.
  </verify>
  <done>Tabs tests pass with coverage of all functions and error paths.</done>
</task>

<task type="auto">
  <name>Task 3: Verify coverage thresholds</name>
  <files>src/utils/storage.test.ts, src/utils/tabs.test.ts</files>
  <action>
Run coverage for both modules and verify >90% threshold:

```bash
npm run test:coverage -- --run src/utils/storage.test.ts src/utils/tabs.test.ts
```

Check coverage report for:
- storage.ts: all functions, error catch blocks
- tabs.ts: all functions, error catch blocks

Add tests for any uncovered branches. Common gaps:
- Error handling catch blocks (may need to mock storage.local.get to throw)
- Edge cases in focusTab (tab exists but window focus fails)

To test error paths, mock storage to throw:
```typescript
vi.spyOn(chrome.storage.local, 'get').mockRejectedValue(new Error('Storage error'));
```
  </action>
  <verify>
`npm run test:coverage -- --run src/utils/storage.test.ts src/utils/tabs.test.ts 2>&1 | grep -E "storage|tabs"` shows >90% coverage for both modules.
  </verify>
  <done>Storage and tabs modules have >90% coverage.</done>
</task>

</tasks>

<verification>
1. `npm test -- --run src/utils/storage.test.ts src/utils/tabs.test.ts` passes
2. Coverage >90% for both storage.ts and tabs.ts
3. Error handling paths tested (silent fallback behavior)
4. All exported functions have test coverage
</verification>

<success_criteria>
- [ ] loadState, saveState, getUrlDetection, setUrlDetection, clearState tested
- [ ] focusTab, updateTabUrl, closeTab, queryZendeskTabs tested
- [ ] Error handling (catch blocks) covered
- [ ] Coverage >90% for both modules
- [ ] All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-testing-quality/04-03-SUMMARY.md`
</output>
