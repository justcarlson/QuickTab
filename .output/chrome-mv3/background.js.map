{"version":3,"file":"background.js","sources":["../../node_modules/wxt/dist/utils/define-background.mjs","../../node_modules/wxt/dist/browser.mjs","../../node_modules/@wxt-dev/browser/src/index.mjs","../../src/utils/storage.ts","../../src/utils/tabs.ts","../../src/utils/url-matching.ts","../../entrypoints/background.ts"],"sourcesContent":["export function defineBackground(arg) {\n  if (arg == null || typeof arg === \"function\") return { main: arg };\n  return arg;\n}\n","import { browser as _browser } from \"@wxt-dev/browser\";\nexport const browser = _browser;\nexport {};\n","// #region snippet\nexport const browser = globalThis.browser?.runtime?.id\n  ? globalThis.browser\n  : globalThis.chrome;\n// #endregion snippet\n","/**\n * Type-safe Chrome storage wrapper with storage-first architecture\n * Implements silent fallback on errors per CONTEXT.md\n */\n\nimport type { StorageSchema, UrlDetectionMode, ZendeskTabInfo } from \"./types\";\n\n/** Storage key for QuickTab state */\nconst STORAGE_KEY = \"quicktab_state\" as const;\n\n/** Default state when storage is empty or unavailable */\nconst DEFAULT_STATE: StorageSchema[\"quicktab_state\"] = {\n\tzendeskTabs: {},\n};\n\n/**\n * Load state from chrome.storage.local\n * Storage-first pattern: always load fresh state on each operation\n *\n * @returns Current state or DEFAULT_STATE on error\n */\nexport async function loadState(): Promise<StorageSchema[\"quicktab_state\"]> {\n\ttry {\n\t\tconst result = await chrome.storage.local.get(STORAGE_KEY);\n\t\treturn (result[STORAGE_KEY] as StorageSchema[\"quicktab_state\"]) ?? DEFAULT_STATE;\n\t} catch (error) {\n\t\t// Silent fallback per CONTEXT.md - extension works but state won't survive restart\n\t\tconsole.warn(\"QuickTab: Storage read failed, using default state\", error);\n\t\treturn DEFAULT_STATE;\n\t}\n}\n\n/**\n * Save state to chrome.storage.local\n * Storage-first pattern: save immediately after modifications\n *\n * @param state - The state to persist\n */\nexport async function saveState(state: StorageSchema[\"quicktab_state\"]): Promise<void> {\n\ttry {\n\t\tawait chrome.storage.local.set({ [STORAGE_KEY]: state });\n\t} catch (error) {\n\t\t// Silent fallback per CONTEXT.md - no user-visible error\n\t\tconsole.warn(\"QuickTab: Storage write failed\", error);\n\t}\n}\n\n/**\n * Get the current URL detection mode\n *\n * @returns Current mode or 'allUrls' as default\n */\nexport async function getUrlDetection(): Promise<UrlDetectionMode> {\n\ttry {\n\t\tconst result = await chrome.storage.local.get(\"urlDetection\");\n\t\treturn (result.urlDetection as UrlDetectionMode) ?? \"allUrls\";\n\t} catch (error) {\n\t\tconsole.warn(\"QuickTab: Failed to read URL detection mode\", error);\n\t\treturn \"allUrls\";\n\t}\n}\n\n/**\n * Set the URL detection mode\n *\n * @param mode - The detection mode to set\n */\nexport async function setUrlDetection(mode: UrlDetectionMode): Promise<void> {\n\ttry {\n\t\tawait chrome.storage.local.set({ urlDetection: mode });\n\t} catch (error) {\n\t\tconsole.warn(\"QuickTab: Failed to write URL detection mode\", error);\n\t}\n}\n\n/**\n * Clear all QuickTab state from storage\n * Used on extension update per CONTEXT.md (clean restart)\n */\nexport async function clearState(): Promise<void> {\n\ttry {\n\t\tawait chrome.storage.local.remove(STORAGE_KEY);\n\t} catch (error) {\n\t\tconsole.warn(\"QuickTab: Failed to clear state\", error);\n\t}\n}\n\n// Re-export types for convenience\nexport type { ZendeskTabInfo, UrlDetectionMode, StorageSchema };\n","/**\n * Type-safe Chrome tabs wrapper with defensive error handling\n * All tab operations wrapped in try/catch for defensive handling per RESEARCH.md pitfall #3\n */\n\n/**\n * Focus a tab and bring its window to front.\n * Per CONTEXT.md: Different window = focus only, bring window to front, don't move tabs.\n *\n * @param tabId - ID of the tab to focus\n * @returns true if tab was focused, false if tab no longer exists\n */\nexport async function focusTab(tabId: number): Promise<boolean> {\n\ttry {\n\t\tconst tab = await chrome.tabs.get(tabId);\n\t\tawait chrome.tabs.update(tabId, { active: true, highlighted: true });\n\t\tawait chrome.windows.update(tab.windowId, { focused: true });\n\t\treturn true;\n\t} catch {\n\t\t// Tab no longer exists - caller should clean up from storage\n\t\treturn false;\n\t}\n}\n\n/**\n * Update a tab's URL.\n * Per CONTEXT.md: Update URL when routing - navigate existing tab to exact new URL.\n *\n * @param tabId - ID of the tab to update\n * @param url - New URL to navigate to\n * @returns true if tab was updated, false if tab no longer exists\n */\nexport async function updateTabUrl(tabId: number, url: string): Promise<boolean> {\n\ttry {\n\t\tawait chrome.tabs.update(tabId, { url });\n\t\treturn true;\n\t} catch {\n\t\t// Tab no longer exists\n\t\treturn false;\n\t}\n}\n\n/**\n * Close a tab.\n * Silently ignores if tab already closed.\n *\n * @param tabId - ID of the tab to close\n */\nexport async function closeTab(tabId: number): Promise<void> {\n\ttry {\n\t\tawait chrome.tabs.remove(tabId);\n\t} catch {\n\t\t// Tab already closed - ignore per RESEARCH.md pitfall #3\n\t}\n}\n\n/**\n * Query for Zendesk agent tabs across all windows.\n * Used for re-detecting tabs on extension install/update.\n *\n * @returns Array of tabs matching Zendesk agent URL pattern\n */\nexport async function queryZendeskTabs(): Promise<chrome.tabs.Tab[]> {\n\treturn chrome.tabs.query({ url: \"*://*.zendesk.com/agent/*\" });\n}\n","/**\n * URL matching module for Zendesk agent URLs.\n * Ports legacy app/javascripts/modules/url_match.js to TypeScript.\n *\n * Per CONTEXT.md:\n * - Ignores query parameters and hash fragments\n * - Matches any Zendesk subdomain\n * - Unified matching for tickets, users, organizations\n */\n\nimport type { RouteMatch, RouteType } from \"./types\";\n\n/**\n * Matches Zendesk agent interface routes (/agent/*)\n * Excludes chat and voice routes which are handled separately.\n * Captures the path after /agent/\n */\nconst LOTUS_ROUTE = /^\\/agent\\/(?!chat|voice)(.*)$/;\n\n/**\n * Matches ticket-related routes from various Zendesk URL patterns.\n * Captures the ticket/request identifier.\n */\nconst TICKET_ROUTE = /^\\/(?:agent\\/tickets|tickets|twickets|requests|hc\\/requests)\\/(.*)$/;\n\n/**\n * Restricted routes that should NOT be intercepted.\n * - agent/chat: Chat interface\n * - agent/talk: Voice interface\n * - agent/admin/voice: Voice admin\n * - tickets/{id}/print: Print view\n */\nconst RESTRICTED_ROUTE = /^\\/(agent\\/(chat|talk|admin\\/voice)|tickets\\/\\d+\\/print)/;\n\n/** Zendesk domain suffix for URL validation */\nconst ZENDESK_DOMAIN_SUFFIX = \".zendesk.com\";\n\n/**\n * Match a URL against Zendesk routing patterns.\n *\n * @param urlString - Full URL to match\n * @returns RouteMatch if URL matches a Zendesk route, null otherwise\n *\n * @example\n * matchZendeskUrl('https://company.zendesk.com/agent/tickets/123')\n * // => { subdomain: 'company', path: '/tickets/123', type: 'ticket' }\n *\n * matchZendeskUrl('https://company.zendesk.com/agent/chat')\n * // => null (restricted route)\n */\nexport function matchZendeskUrl(urlString: string): RouteMatch | null {\n\tlet url: URL;\n\ttry {\n\t\turl = new URL(urlString);\n\t} catch {\n\t\treturn null; // Invalid URL\n\t}\n\n\t// Verify zendesk.com domain (any subdomain)\n\tif (!url.hostname.endsWith(ZENDESK_DOMAIN_SUFFIX)) {\n\t\treturn null;\n\t}\n\n\t// Extract subdomain (everything before .zendesk.com)\n\tconst subdomain = url.hostname.slice(0, -ZENDESK_DOMAIN_SUFFIX.length);\n\tif (!subdomain) {\n\t\treturn null; // Root domain without subdomain\n\t}\n\n\t// Use pathname only - ignores query params and hash per CONTEXT.md\n\tconst pathname = url.pathname;\n\n\t// Check restricted routes first (chat, voice, print)\n\tif (RESTRICTED_ROUTE.test(pathname)) {\n\t\treturn null;\n\t}\n\n\t// Try ticket route (higher priority per existing logic)\n\tconst ticketMatch = pathname.match(TICKET_ROUTE);\n\tif (ticketMatch) {\n\t\tconst path = ticketMatch[1]?.replace(\"#/\", \"\") ?? \"\";\n\t\treturn { subdomain, path: `/tickets/${path}`, type: \"ticket\" as RouteType };\n\t}\n\n\t// Try lotus route\n\tconst lotusMatch = pathname.match(LOTUS_ROUTE);\n\tif (lotusMatch) {\n\t\tconst path = lotusMatch[1]?.replace(\"#/\", \"\") ?? \"\";\n\t\treturn { subdomain, path: `/${path}`, type: \"lotus\" as RouteType };\n\t}\n\n\treturn null;\n}\n\n/**\n * Build a Zendesk agent URL from a RouteMatch.\n *\n * @param match - RouteMatch containing subdomain and path\n * @returns Full Zendesk agent URL\n *\n * @example\n * buildZendeskUrl({ subdomain: 'company', path: '/tickets/123', type: 'ticket' })\n * // => 'https://company.zendesk.com/agent/tickets/123'\n */\nexport function buildZendeskUrl(match: RouteMatch): string {\n\treturn `https://${match.subdomain}${ZENDESK_DOMAIN_SUFFIX}/agent${match.path}`;\n}\n\n/**\n * Check if a URL is a Zendesk agent URL.\n *\n * @param url - URL string to check\n * @returns true if URL is a Zendesk agent interface URL\n *\n * @example\n * isZendeskAgentUrl('https://company.zendesk.com/agent/dashboard')\n * // => true\n *\n * isZendeskAgentUrl('https://company.zendesk.com/hc/articles/123')\n * // => false\n */\nexport function isZendeskAgentUrl(url: string): boolean {\n\ttry {\n\t\tconst parsed = new URL(url);\n\t\treturn parsed.hostname.endsWith(ZENDESK_DOMAIN_SUFFIX) && parsed.pathname.startsWith(\"/agent\");\n\t} catch {\n\t\treturn false;\n\t}\n}\n","/**\n * QuickTab Service Worker\n *\n * Intercepts Zendesk navigation events and routes them to existing agent tabs.\n * Implements storage-first architecture for MV3 persistence.\n *\n * Per RESEARCH.md and CONTEXT.md:\n * - All event listeners registered synchronously at module scope\n * - State loaded fresh from storage on each handler (storage-first)\n * - No global state variables (service worker terminates)\n */\n\nimport {\n\tclearState,\n\tgetUrlDetection,\n\tloadState,\n\tsaveState,\n\tsetUrlDetection,\n} from \"@/src/utils/storage\";\nimport { closeTab, focusTab, queryZendeskTabs, updateTabUrl } from \"@/src/utils/tabs\";\nimport type { RouteMatch, UrlDetectionMode, ZendeskTabInfo } from \"@/src/utils/types\";\nimport { buildZendeskUrl, isZendeskAgentUrl, matchZendeskUrl } from \"@/src/utils/url-matching\";\n\n/**\n * Deduplication: Track recently processed navigations to prevent double-firing.\n * Key: \"tabId:url\", Value: timestamp\n * NOTE: This in-memory state is acceptable per MV3 patterns because:\n * - It's only used for short-term deduplication (cleared after 1 second)\n * - Loss on service worker termination is acceptable (just means no dedup)\n * - Not persisted to storage (would add unnecessary latency)\n */\nconst recentNavigations = new Map<string, number>();\nconst NAVIGATION_DEDUPE_MS = 1000; // 1 second window for deduplication\n\n/**\n * Message types for popup communication\n */\ninterface GetStatusMessage {\n\ttype: \"getStatus\";\n}\n\ninterface SetModeMessage {\n\ttype: \"setMode\";\n\tmode: UrlDetectionMode;\n}\n\ntype BackgroundMessage = GetStatusMessage | SetModeMessage;\n\ninterface GetStatusResponse {\n\tmode: UrlDetectionMode;\n}\n\n/**\n * Check if a navigation was recently processed (deduplication).\n * If not recently processed, marks it as processed and returns false.\n * If already processed within the dedupe window, returns true.\n *\n * @param tabId - Tab ID of the navigation\n * @param url - URL being navigated to\n * @returns true if this navigation should be skipped (already processed)\n */\nfunction isDuplicateNavigation(tabId: number, url: string): boolean {\n\tconst key = `${tabId}:${url}`;\n\tconst now = Date.now();\n\n\t// Clean up old entries (older than dedupe window)\n\tfor (const [k, timestamp] of recentNavigations.entries()) {\n\t\tif (now - timestamp > NAVIGATION_DEDUPE_MS) {\n\t\t\trecentNavigations.delete(k);\n\t\t}\n\t}\n\n\t// Check if recently processed\n\tconst lastProcessed = recentNavigations.get(key);\n\tif (lastProcessed && now - lastProcessed < NAVIGATION_DEDUPE_MS) {\n\t\treturn true; // Skip this duplicate\n\t}\n\n\t// Mark as processed\n\trecentNavigations.set(key, now);\n\treturn false;\n}\n\n/**\n * Update action icon for all Zendesk agent tabs based on detection mode.\n * Per existing behavior: enabled icon if mode !== 'noUrls', disabled otherwise.\n *\n * @param mode - Current URL detection mode\n */\nasync function setActionIcon(mode: UrlDetectionMode): Promise<void> {\n\tconst iconPath =\n\t\tmode !== \"noUrls\" ? \"/images/icons/icon38-enabled.png\" : \"/images/icons/icon38-disabled.png\";\n\n\t// Query all Zendesk agent tabs and update their icons\n\tconst tabs = await queryZendeskTabs();\n\tfor (const tab of tabs) {\n\t\tif (tab.id) {\n\t\t\ttry {\n\t\t\t\tawait chrome.action.setIcon({ tabId: tab.id, path: iconPath });\n\t\t\t} catch {\n\t\t\t\t// Tab may have closed, ignore\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Find the most recently active tab for a given subdomain from LIVE browser tabs.\n * Per CONTEXT.md: Multiple matching tabs use most recently active tab.\n *\n * CRITICAL: This queries LIVE tabs and validates they have /agent/* URLs,\n * matching the original extension behavior. The storage state is only used\n * for lastActive timestamps when multiple tabs match.\n *\n * @param subdomain - Zendesk subdomain to match\n * @param excludeTabId - Tab ID to exclude from search (the source tab)\n * @param zendeskTabs - Storage state for lastActive timestamps\n * @returns Tab object of most recently active tab, or null if none found\n */\nasync function findExistingAgentTab(\n\tsubdomain: string,\n\texcludeTabId: number,\n\tzendeskTabs: Record<number, ZendeskTabInfo>,\n): Promise<chrome.tabs.Tab | null> {\n\t// Query LIVE tabs matching this subdomain's agent interface\n\t// This matches original behavior: tabs.query('*://' + subdomain + '.zendesk.com/agent/*')\n\tconst pattern = `*://${subdomain}.zendesk.com/agent/*`;\n\tconst liveTabs = await chrome.tabs.query({ url: pattern });\n\n\tif (liveTabs.length === 0) {\n\t\treturn null;\n\t}\n\n\t// Filter out the source tab and find the most recently active\n\tlet bestTab: chrome.tabs.Tab | null = null;\n\tlet bestTime = 0;\n\n\tfor (const tab of liveTabs) {\n\t\tif (!tab.id || tab.id === excludeTabId) continue;\n\t\tif (!tab.url) continue;\n\n\t\t// Additional validation: URL must match agent interface pattern\n\t\t// (defensive check - query should already filter this)\n\t\tif (!isZendeskAgentUrl(tab.url)) continue;\n\n\t\t// Use storage state for lastActive timestamp if available, otherwise use 0\n\t\tconst lastActive = zendeskTabs[tab.id]?.lastActive ?? 0;\n\n\t\tif (lastActive > bestTime || bestTab === null) {\n\t\t\tbestTime = lastActive;\n\t\t\tbestTab = tab;\n\t\t}\n\t}\n\n\treturn bestTab;\n}\n\n/**\n * Handle navigation interception and tab routing.\n * Core routing logic matching original extension behavior:\n * 1. Query LIVE tabs for matching subdomain + /agent/* URL\n * 2. Find first matching tab (or most recently active if tracked)\n * 3. Update that tab's URL and focus it\n * 4. Close the source tab\n *\n * @param sourceTabId - Tab ID that initiated the navigation\n * @param sourceUrl - URL being navigated to\n * @param match - Matched route details\n */\nasync function handleNavigation(\n\tsourceTabId: number,\n\t_sourceUrl: string,\n\tmatch: RouteMatch,\n): Promise<void> {\n\tconst state = await loadState();\n\n\t// Find existing LIVE agent tab for this subdomain (not the source tab)\n\tconst existingTab = await findExistingAgentTab(match.subdomain, sourceTabId, state.zendeskTabs);\n\n\tif (existingTab?.id) {\n\t\t// Route to existing tab\n\t\tconst targetUrl = buildZendeskUrl(match);\n\t\tconst updated = await updateTabUrl(existingTab.id, targetUrl);\n\n\t\tif (updated) {\n\t\t\tawait focusTab(existingTab.id);\n\t\t\tawait closeTab(sourceTabId);\n\n\t\t\t// Update lastActive for the target tab\n\t\t\tstate.zendeskTabs[existingTab.id] = {\n\t\t\t\tsubdomain: match.subdomain,\n\t\t\t\tlastActive: Date.now(),\n\t\t\t};\n\n\t\t\t// Remove source tab from tracking (it's now closed)\n\t\t\tdelete state.zendeskTabs[sourceTabId];\n\t\t\tawait saveState(state);\n\t\t}\n\t\t// If update failed, tab no longer exists - just let source tab continue\n\t} else {\n\t\t// No existing agent tab found, track this one as a new agent tab\n\t\tstate.zendeskTabs[sourceTabId] = {\n\t\t\tsubdomain: match.subdomain,\n\t\t\tlastActive: Date.now(),\n\t\t};\n\t\tawait saveState(state);\n\t}\n}\n\n/**\n * Track a tab as a Zendesk agent tab in state.\n *\n * @param tabId - Tab ID to track\n * @param url - Current URL of the tab\n */\nasync function trackTab(tabId: number, url: string): Promise<void> {\n\tconst state = await loadState();\n\n\t// Extract subdomain from URL\n\tconst match = matchZendeskUrl(url);\n\tif (!match) {\n\t\t// URL matched filter but not our routes - try parsing for subdomain directly\n\t\ttry {\n\t\t\tconst parsed = new URL(url);\n\t\t\tconst subdomain = parsed.hostname.replace(\".zendesk.com\", \"\");\n\t\t\tif (subdomain && isZendeskAgentUrl(url)) {\n\t\t\t\tstate.zendeskTabs[tabId] = {\n\t\t\t\t\tsubdomain,\n\t\t\t\t\tlastActive: Date.now(),\n\t\t\t\t};\n\t\t\t\tawait saveState(state);\n\t\t\t}\n\t\t} catch {\n\t\t\t// Invalid URL, ignore\n\t\t}\n\t\treturn;\n\t}\n\n\tstate.zendeskTabs[tabId] = {\n\t\tsubdomain: match.subdomain,\n\t\tlastActive: Date.now(),\n\t};\n\tawait saveState(state);\n}\n\nexport default defineBackground(() => {\n\t// Console log for lifecycle debugging per CONTEXT.md\n\tconsole.log(\"QuickTab service worker started\", { id: browser.runtime.id });\n\n\t// =================================================================\n\t// ALL EVENT LISTENERS REGISTERED SYNCHRONOUSLY AT MODULE SCOPE\n\t// Per RESEARCH.md: NO async in defineBackground signature\n\t// =================================================================\n\n\t/**\n\t * Handle extension installation and updates\n\t */\n\tchrome.runtime.onInstalled.addListener(async (details) => {\n\t\tif (details.reason === \"install\") {\n\t\t\t// Open welcome page on first install\n\t\t\tconst welcomeUrl = chrome.runtime.getURL(\"welcome.html\");\n\t\t\tawait chrome.tabs.create({ url: welcomeUrl });\n\t\t}\n\n\t\tif (details.reason === \"update\") {\n\t\t\t// Reset state on extension update per CONTEXT.md (clean restart)\n\t\t\tawait clearState();\n\t\t\tconsole.log(\"QuickTab: Extension updated - state reset\");\n\t\t}\n\n\t\t// Re-detect existing Zendesk tabs after install/update\n\t\tconst tabs = await queryZendeskTabs();\n\t\tif (tabs.length > 0) {\n\t\t\tconst state = await loadState();\n\t\t\tfor (const tab of tabs) {\n\t\t\t\tif (tab.id && tab.url) {\n\t\t\t\t\tconst match = matchZendeskUrl(tab.url);\n\t\t\t\t\tif (match) {\n\t\t\t\t\t\tstate.zendeskTabs[tab.id] = {\n\t\t\t\t\t\t\tsubdomain: match.subdomain,\n\t\t\t\t\t\t\tlastActive: Date.now(),\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if (isZendeskAgentUrl(tab.url)) {\n\t\t\t\t\t\t// Agent URL but not matching our routes - still track it\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst parsed = new URL(tab.url);\n\t\t\t\t\t\t\tconst subdomain = parsed.hostname.replace(\".zendesk.com\", \"\");\n\t\t\t\t\t\t\tstate.zendeskTabs[tab.id] = {\n\t\t\t\t\t\t\t\tsubdomain,\n\t\t\t\t\t\t\t\tlastActive: Date.now(),\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\t// Invalid URL, skip\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tawait saveState(state);\n\t\t\tconsole.log(\"QuickTab: Re-detected\", tabs.length, \"Zendesk tabs\");\n\t\t}\n\t});\n\n\t/**\n\t * Navigation interception - matching original extension behavior exactly.\n\t *\n\t * The original uses BOTH onBeforeNavigate AND onCommitted, both calling\n\t * the same handler. We use deduplication to prevent double-processing.\n\t *\n\t * NO transitionType filtering - the original doesn't filter.\n\t * The key is that we only close the source tab IF we successfully\n\t * route to a DIFFERENT existing agent tab.\n\t */\n\tchrome.webNavigation.onBeforeNavigate.addListener(\n\t\tasync (details) => {\n\t\t\t// Only handle main frame navigation\n\t\t\tif (details.frameId !== 0) return;\n\n\t\t\t// DEBUG: Log navigation details\n\t\t\tconsole.log(\"QuickTab onBeforeNavigate:\", {\n\t\t\t\turl: details.url,\n\t\t\t\ttabId: details.tabId,\n\t\t\t});\n\n\t\t\t// Deduplication: Skip if we recently processed this exact navigation\n\t\t\tif (isDuplicateNavigation(details.tabId, details.url)) return;\n\n\t\t\tconst detection = await getUrlDetection();\n\t\t\tif (detection === \"noUrls\") return;\n\n\t\t\tconst match = matchZendeskUrl(details.url);\n\t\t\tif (!match) return;\n\n\t\t\t// For ticketUrls mode, only intercept ticket routes\n\t\t\tif (detection === \"ticketUrls\" && match.type !== \"ticket\") return;\n\n\t\t\tawait handleNavigation(details.tabId, details.url, match);\n\t\t},\n\t\t{ url: [{ hostSuffix: \"zendesk.com\" }] },\n\t);\n\n\t/**\n\t * Backup navigation handler - fires after navigation commits.\n\t * Handles redirects and programmatic navigation.\n\t * Same logic as onBeforeNavigate, deduplication prevents double-processing.\n\t */\n\tchrome.webNavigation.onCommitted.addListener(\n\t\tasync (details) => {\n\t\t\t// Only handle main frame navigation\n\t\t\tif (details.frameId !== 0) return;\n\n\t\t\t// DEBUG: Log navigation details\n\t\t\tconsole.log(\"QuickTab onCommitted:\", {\n\t\t\t\turl: details.url,\n\t\t\t\ttabId: details.tabId,\n\t\t\t\ttransitionType: details.transitionType,\n\t\t\t});\n\n\t\t\t// Deduplication: Skip if we recently processed this exact navigation\n\t\t\tif (isDuplicateNavigation(details.tabId, details.url)) return;\n\n\t\t\tconst detection = await getUrlDetection();\n\t\t\tif (detection === \"noUrls\") return;\n\n\t\t\tconst match = matchZendeskUrl(details.url);\n\t\t\tif (!match) return;\n\n\t\t\t// For ticketUrls mode, only intercept ticket routes\n\t\t\tif (detection === \"ticketUrls\" && match.type !== \"ticket\") return;\n\n\t\t\tawait handleNavigation(details.tabId, details.url, match);\n\t\t},\n\t\t{ url: [{ hostSuffix: \"zendesk.com\" }] },\n\t);\n\n\t/**\n\t * Track Zendesk agent tabs when page loads\n\t * Shows action icon and updates tab tracking state\n\t */\n\tchrome.webNavigation.onDOMContentLoaded.addListener(\n\t\tasync (details) => {\n\t\t\t// Only handle main frame\n\t\t\tif (details.frameId !== 0) return;\n\n\t\t\t// Track this tab\n\t\t\tawait trackTab(details.tabId, details.url);\n\n\t\t\t// Enable action icon for this tab\n\t\t\tchrome.action.enable(details.tabId);\n\n\t\t\t// Set icon state based on detection mode\n\t\t\tconst mode = await getUrlDetection();\n\t\t\tawait setActionIcon(mode);\n\t\t},\n\t\t{ url: [{ urlContains: \"zendesk.com/agent\" }] },\n\t);\n\n\t/**\n\t * Message handler for popup communication\n\t * Handles getStatus and setMode messages\n\t */\n\tchrome.runtime.onMessage.addListener(\n\t\t(\n\t\t\tmessage: BackgroundMessage,\n\t\t\t_sender: chrome.runtime.MessageSender,\n\t\t\tsendResponse: (response: GetStatusResponse | boolean) => void,\n\t\t) => {\n\t\t\t// Handle each message type\n\t\t\tif (message.type === \"getStatus\") {\n\t\t\t\t// Return current detection mode\n\t\t\t\tgetUrlDetection()\n\t\t\t\t\t.then((mode) => {\n\t\t\t\t\t\tsendResponse({ mode });\n\t\t\t\t\t})\n\t\t\t\t\t.catch(() => {\n\t\t\t\t\t\tsendResponse({ mode: \"allUrls\" });\n\t\t\t\t\t});\n\t\t\t\t// Return true to indicate async response\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (message.type === \"setMode\") {\n\t\t\t\t// Save new mode and update icons\n\t\t\t\tsetUrlDetection(message.mode)\n\t\t\t\t\t.then(() => setActionIcon(message.mode))\n\t\t\t\t\t.then(() => {\n\t\t\t\t\t\tsendResponse(true);\n\t\t\t\t\t})\n\t\t\t\t\t.catch(() => {\n\t\t\t\t\t\tsendResponse(false);\n\t\t\t\t\t});\n\t\t\t\t// Return true to indicate async response\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// Unknown message type\n\t\t\treturn false;\n\t\t},\n\t);\n});\n"],"names":["defineBackground","arg","browser","STORAGE_KEY","DEFAULT_STATE","loadState","error","saveState","state","getUrlDetection","setUrlDetection","mode","clearState","focusTab","tabId","tab","updateTabUrl","url","closeTab","queryZendeskTabs","LOTUS_ROUTE","TICKET_ROUTE","RESTRICTED_ROUTE","ZENDESK_DOMAIN_SUFFIX","matchZendeskUrl","urlString","subdomain","pathname","ticketMatch","path","lotusMatch","buildZendeskUrl","match","isZendeskAgentUrl","parsed","recentNavigations","NAVIGATION_DEDUPE_MS","isDuplicateNavigation","key","now","k","timestamp","lastProcessed","setActionIcon","iconPath","tabs","findExistingAgentTab","excludeTabId","zendeskTabs","pattern","liveTabs","bestTab","bestTime","lastActive","handleNavigation","sourceTabId","_sourceUrl","existingTab","targetUrl","trackTab","definition","details","welcomeUrl","detection","message","_sender","sendResponse"],"mappings":"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","x_google_ignoreList":[0,1,2]}